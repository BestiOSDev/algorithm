<!--ts-->

<div align = "center"><font size = 4>二叉树</font></div>

* [一、二叉树基础（上）](#一、二叉树基础（上）)

   * [1 树的基本概念](#1 树的基本概念)
   * [2 二叉树种类](#2 二叉树种类)
   * [3 二叉树存储方式](#3-二叉树存储方式)
   * [4 二叉树的遍历及其递归（O(n)）实现](#4-二叉树的遍历及其递归（O(n)）实现)
   * [5 课后思考题](#5-课后思考题)
* [二、二叉树基础（下）— 二叉查找树 or 二叉排序树](#二、二叉树基础（下）— 二叉查找树 or 二叉排序树)

   * [1 二叉查找树概念（Binary Search Tree）](#1 二叉查找树概念（Binary Search Tree）)
   * [2 二叉查找树—查找](#2 二叉查找树—查找)
   * [3 二叉查找树—插入](#3 二叉查找树—插入)
   * [5 二叉查找树的其他操作](#5 二叉查找树的其他操作)
   * [6 支持重复数据的二叉查找树](#6 支持重复数据的二叉查找树)
   * [7 二叉查找树的时间复杂度分析](#7 二叉查找树的时间复杂度分析)
   * [8 散列表 vs 二叉查找树](#8 散列表 vs 二叉查找树)
   * [9 练习](#9 练习)


#### 一、二叉树基础（上）

---

<font color="green">二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</font>



##### 1 树的基本概念

- 父节点、子节点、兄弟节点、根节点（树根）、叶子节点/叶节点（没有子节点的节点）。

- 高度（节点到叶子节点的最长边数）、深度（根节点到该节点的边数）、层（节点的深度+1）、树的高度（根节点到叶子节点最长边数）

  <div align = "center"> 
    <img src = "pics/二叉树/树的基本概念.png" width = "400px"/> 
  </div><br>
  <div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

##### 2 二叉树种类

- 普通的二叉树：除了下面外的其他二叉树，都是普通二叉树。

- 满二叉树：叶子节点全部在最底层，除了叶子节点外，每个节点都有左右两个子节点。（一种特殊的完全二叉树）

  <div align = "center"> 
    <img src = "pics/二叉树/满二叉树.png" width = "150px"/> 
  </div><br>
  <div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

- 完全二叉树：叶子节点在最底下二层，最后一层的叶子节点都靠左排列，除了最后一层节点外，其他层节点个数达到最大！

  <div align = "center"> 
    <img src = "pics/二叉树/完全二叉树.png" width = "150px"/> 
  </div><br>
  <div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

##### 3 二叉树存储方式

- 链式存储：基于链表的方法，每个节点 3 个元素，一个存储数据，另两个存储指针。
- 顺序存储：基于数组的存储方法。会牺牲一个空间，在数组索引 0 位置处。在 1 位置处是表明根节点！



##### 4 二叉树的遍历及其递归（O(n)）实现

- 前序遍历：先打印该节点，然后打印其左子树，再打印右子树。
- 中序遍历：先打印左子树，在打印该节点，在打印右子树。
- 后序遍历：先打印左子树，在打印右子树，在打印该节点。

```c++
前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
```

##### 5 课后思考题

1. 二叉树的层序遍历实现？



#### 二、二叉树基础（下）— 二叉查找树 or 二叉排序树

---

支持动态数据集合快速插入、删除、查找操作。那么这里应该是基于链表的存储方式！

<font  color="green">既然有了这么高效的散列表（O(1)），使用二叉树的地方是不是都可以替换成散列表呢？有没有其他哪些地方散列表做不了，必须要用二叉树来做的呢？</font>



##### 1 二叉查找树概念（Binary Search Tree）

要求：在树中任意一个节点，左子树中每个节点的值 < 该节点的值，而右子树的节点值 > 该节点的值。

<div align = "center"> 
  <img src = "pics/二叉树/二叉搜索树.png" width = 500px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

##### 2 二叉查找树—查找

根据二叉查找树基本概念，我们可以根据类似二分的思想，在左子树和右子树中递归查找。当然实现方式可以直接用循环！



##### 3 二叉查找树—插入

与上面查找相似，同样是类似二分思路来插入数据，只不过需要提前判断右（左）子节点是不是为空，如果是空，直接插入返回即可。



#####　4 二叉查找树—删除

- 第一种情况，删除的节点没有子节点，那么直接将该节点删除即可（但是要注意清除父亲节点的相应指针（左子节点 or 右子节点））。
- 第二种情况，删除的节点有一个子节点，那么直接让其父节点指向该节点的子节点！
- 第三种情况，删除的节点有两个子节点，那么需要找到该节点的右子树中的最小值，然后将该值替换到要删除的节点位置，然后删除最小值对应的节点（记住要清零其父亲节点内部的某个指针，还要判断他有没有右儿子节点！）。

下面专栏的代码实现的就比较好

```java
public void delete(int data) {
  Node p = tree; // p 指向要删除的节点，初始化指向根节点
  Node pp = null; // pp 记录的是 p 的父节点
  while (p != null && p.data != data) {
    pp = p;
    if (data > p.data) p = p.right;
    else p = p.left;
  }
  if (p == null) return; // 没有找到

  // 要删除的节点有两个子节点
  if (p.left != null && p.right != null) { // 查找右子树中最小节点
    Node minP = p.right;
    Node minPP = p; // minPP 表示 minP 的父节点
    while (minP.left != null) {
      minPP = minP;
      minP = minP.left;
    }
    p.data = minP.data; // 将 minP 的数据替换到 p 中
    p = minP; // 下面就变成了删除 minP 了 ，即使他有右儿子节点，下面也能够处理！
    pp = minPP;
  }

  // 删除节点是叶子节点或者仅有一个子节点
  Node child; // p 的子节点
  if (p.left != null) child = p.left;
  else if (p.right != null) child = p.right;
  else child = null;
	// 注意这个 java 版本没有内存的释放操作！
  if (pp == null) tree = child; // 删除的是根节点
  else if (pp.left == p) pp.left = child;
  else pp.right = child;
}
```



##### 5 二叉查找树的其他操作

除了上面的插入、删除、查找外，还有快速查找最大节点、最小节点、前驱节点、后继节点。**重要特性**：**中序遍历二叉查找树，可以输出有序的数据序列（小->大），时间复杂度为 $O(n)$，非常高效！**可以利用堆栈存储中序遍历结果得到从大到小的输出！这样空间复杂度就是 $O(n)$。



##### 6 支持重复数据的二叉查找树

上面的操作每个节点存储的数据都是单个数值 ，但是实际操作过程中，会利用对象的某个字段作为键值（Key）来构建二叉查找树，把对象的其他字段叫做**卫星数据**。 这样就有可能会有重复的数据（键值 Key）。解决方案：

- 在二叉查找树中每个节点除了存储键值外，还要保留一个动态扩容的数组或者链表来存储对像的卫星数据。
- 每个节点只存储一个数据（键值 + 卫星数据），在查找插入时，对于重复元素，我们把按照插入的方法，将其插入到右子树中，其实就是插入到最左子节点处！当要查找数据时，遇到键值相同的节点后仍然需要在其右子树中继续查找（只要查找左子节点即可！），直到遇到空！这样就把所有键值相同的节点找到。对于删除，我们直接按照上面讲解的普通二叉查找数的删除方法依次删除即可！



##### 7 二叉查找树的时间复杂度分析

不同树的形状，会影响复杂度，比如下面图片的三种情况

<div align = "center"> 
  <img src = "pics/二叉树/二叉查找树时间复杂度.png" width = 400px"/> 
</div><br>
<div align = "center"><font size = 2>本图片来自极客时间《数据结构与算法之美》专栏</font></div></br>

时间复杂度与树的高度成正比，也就是 $O(height) = O(L-1)$，L 代表树有多少层。可以根据下面方法计算高度关于节点总个数的关系，即可推导处 L 关于节点个数 n 的关系式。L~ [log2(n+1), log2n +1]

```
n >= 1+2+4+8+...+2^(L-2)+1
n <= 1+2+4+8+...+2^(L-2)+2^(L-1)
```

一般情况下，树不是完全二叉树，那么其时间复杂度就会增高，下面就会讲解平衡二叉树使得插入、删除、查找操作的时间复杂度为 $O(logn)$。



##### 8 散列表 vs 二叉查找树

1. 散列表数据是无序的，如果要有序遍历，那么需要先排序，二叉查找树直接可以在 $O(n)$ 复杂度下有序输出
2. 散列表扩容耗时多，且遇到散列冲突时，性能非常不稳定，尽管二叉查找树性能不稳定，但是实际使用时都会用平衡二叉树，其比较稳定，删除、查找、插入的时间复杂度为 $O(n)$。
3. 尽管散列表查找是常量级的，但是因为哈希冲突的存在（需要遍历链表或者数组），这个常量不一定要比 $O(logn)$ 小，所以实际查找速度可能不一定比 $O(logn)$ 快，加上哈希函数耗时，也不一定就比平衡二叉树效率高！
4. 散列表构造复杂（散列函数设计、冲突解决方案、扩容、缩容），平衡二叉树只需要平衡性这一个问题。且已经有成熟的方案。
5. 为了避免过多的散列冲突，散列表装载因子不能太小，特别是基于开放寻址法解决冲突的散列表，所以会浪费空间。

综合考虑，平衡二叉树在某些方面还是优于散列表的



##### 9 练习

leetcode 538：

leetcode 450：二叉查找树的删除操作

leetcode 104：二叉查找树的的高度计算

leetcode 102： Binary Tree Level Order Traversal（层序遍历方法）

输出二叉树的确切高度（递归和层序遍历方法）、二叉搜索树的构建（查找、删除、插入、支持重复数据的二叉查找树）、二叉树的遍历（前序、中序、后序遍历、层序遍历）。